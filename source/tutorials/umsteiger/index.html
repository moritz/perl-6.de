[[[setvar title Perl 6-Tutorial für Programmier anderer Programmiersprachen]]]
[[[menu main tut umsteiger]]]
<div id="content">

    <h1 id="introduction">Perl 6-Tutorial</h1>

    <h2>Zielgruppe</h2>

    <p>Dieses Tutorial richtet sich an Interessierte, die schon in einer
    anderen Programmiersprache etwas programmieren können, aber bisher
    kein Perl können.</p>

    <h2>Compiler, Interpreter und VM</h2>

    <p>Perl 6 ist eine Sprachspezifikation, zu der mehrere Implementierungen
    in Entwicklung sind.</p>

    <p>Vom Design her kann Perl 6 sowohl interpretiert als auch kompiliert
    werden. <a href="http://rakudo.de/">Rakudo</a> ist ein Perl 6-Compiler,
    der Bytecode für die <a href="http://www.parrotcode.org/">Parrot
    Virtual Maschine</a> erzeugt. Das geschieht aber Transparent für
    den Benutzer, d.h. er ruft einfach <code>perl6
    <em>scriptname</em></code> auf, und dann führt perl6 das Skript
    aus.</p>

    <p>Die Implementierung von perl6 ist aber noch nicht sehr weit
    fortgeschritten. Am benutzbarsten ist zur Zeit eine andere
    Implementirung, <a href="http://www.pugscode.org/">Pugs</a>, 
    das "Perl User's Golfing System", ein in Haskell 
    geschriebener Perl 6-Interpreter.</p>

    <p>Zusammen mit Pugs werden umfangreiche Testcases entwickelt, die
    sicherstellen, dass Pugs und die entgültige Version von perl6
    kompatibel bleiben.</p>

    <p>Im Moment ist es sicher am einfachsten, sich pugs herunterzuladen und
    damit die Perl 6-Programme auszuführen.</p>
    <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h2>Was ist anders als in anderen Sprachen?</h2>

    <p>Perl 6 ist in einiger Hinsicht anders als "normale"
    Programmiersprachen. Viele kommen sicher daher, dass Perl nicht von
    Informatikern, sondern vor allem von einem Linguisten designed wurde.</p>
    
    <p>Perl 6 bietet Kontextsensitivität. Das bedeutet, dass bestimmte
    Konstrukte (sowohl grammatikalische als auch semantische) je nach Umgebung
    eine andere Bedeutung haben können. Das soll größtmögliche Intuitivität
    erlauben.</p>

    <p>Perls Variablen beginnen mit einem Sonderzeichen, <em>Sigil</em>
    genannt. Diese geben Auskunft über den (groben) Typ der Variable, und
    ermöglichen es, sie in Zeichenketten zu interpolieren.</p>

    <h2>Einfache Programme</h2>

    <p>So sieht ein kurzes Perl 6-Programm aus:</p>

<pre>
[[[syntax perl6]]]
use v6;

my $number = 2 * 3 + 5;
say "Die Zahl ist ", $number;
[[[endsyntax]]]
</pre>
    <p>Die Zeile <code>use v6;</code> sagt dem Compiler, dass es sich um
    Perl-Code für Version 6 handelt. Wenn man probiert, den Code auf
    einem älteren Perl-Interpreter auszuführen, wird er
    vergeblich nach dem Modul (oder der Version) <code>v6</code> suchen 
    und eine Fehlermeldung ausgeben.</p>

    <p>Die Zeile 
    <code>my $number = 2 * 3 + 5;</code> deklariert mit dem
    Schlüsselwort <code>my</code> eine Variable namens
    <code>$number</code>, und weist ihr den Wert 11 zu.</p>

    <p>Wie bereits besprochen beginnen alle Veriablen beginnen mit einem 
    <em>Sigil</em>. Ein Dollar <code>$</code> steht dabei
    für einen sogeannten Skalar, also ein einzelner Wert.</p>

    <p>So ein Wert kann eine Zahl sein, ein String, eine Referenz oder ein
    Objekt. Es ist zwar möglich, genauere Typen anzugeben, aber es ist
    erforderlich.</p>

    <p>Per Default wird automatisch zwischen Strings und Variablen
    Konvertiert, <code>say 3 * "20 Euro";</code> gibt also den Wert 60
    aus (und eventuell eine Warnung, dass <code>" Euro"</code> nicht numerisch
    ist).</p>

    <p>Die letzte Zeile 
    <code>say "Die Zahl ist ", $number;</code> schließlich gibt den
    String <code>"Die Zahl ist</code> " und danach die Variable
    <code>$number</code> aus.</p>

    <p>Man beachte, dass alle Befehle mit einem Strichpunkt
    <code>;</code> aufhören.</p>

    <p>Man kann beliebig viele Leerzeichen in Perl-Programme
    ausführen, und auch die Befehle über mehrere Zeilen
    verteilen - nicht das Zeilenende, sondern der Strichpunkt definiert
    das Ende eines Befehls. Ausnahme davon ist die Regel, dass ein Strichpunkt
    optional ist, wenn nach einer schliessenden geschweiften Klammer eine neue
    Zeile anfängt.</p>

    <p>Kommentare beginnen mit einem Hash <code>#</code>.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h2>Variablen</h2>

    <p>Variablen sind <strong>Skalare</strong>,
    <strong>Listen</strong> und <strong>Hashes</strong>. Außerdem gibt es ein
    paar seltener gebrauchte Variablentypen wie z.B. Package-Namen.</p>

    <p>Dabei darf es durchaus zwei Variablen mit gleichem Namen aber aber
    unterschiedlichem sigil geben, ohne dass sie kollidieren.</p>

<pre>[% syntax perl6 %]
my @namen = <Helmut Konrad Gerhard Angela>;
my %namen =
    Helmut  => "Kohl",
    Konrad  => "Adenauer",
    Gerhard => "Schröder",
    Angela  => "Merkel",
    ;
[% endsyntax %]</pre>

    <p>Hier sind <code>@namen</code> und <code>%namen</code> zwei verschiedene
    Variablen, da das Sigil zum Name der Variable gehört.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>Skalare</h3>

    <p>Skalare beginnen mit einem Dollar-Zeichen <code>$</code>, und
    enthalten immer genau einen Wert.</p>

    <p>Viele verschiedene Arten von Werten können in einem Skalar
    gespeichert werden: <code>undef</code>, Zahlen, Strings, und
    Referenzen auf Listen, Hashes und andere Objekete.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h4>Zahlen</h4>
    <p>Am einfachsten zu verstehen sind sicherlich die Zahlen:</p>
<pre>[[[syntax perl6]]]
my $i = 1;
my $f = -3.3;
my $complex = 3 + 4i;
[[[endsyntax]]]</pre>
    <p>Eine Zahl kann eine ganze Zahl (<code>Int</code>), eine Fließkommazahl
    (<code>Num</code>) oder eine Komplexe Zahl (<code>Complex</code>) sein.</p>

    <p>Mit Zahlen kann man wie gewohnt rechnen, es stehen die Operatoren
    <code>+</code>
    (Addition), <code>-</code> (Substraktion), <code>*</code> 
    (Multiplikation), <code>/</code> (Divison) und <code>**</code>
    (Potenzierung) zur Verfügung.</p>

    <p>Wie gewohnt gilt Punkt- vor Strichrechnung, und Potenzierung hat
    noch höhere Priorität.</p>

    <p><code>2 + 3 * 2**10</code> ist damit gleichwertig wie <code>2 + (3
    * (2**10))</code>.</p>

    <p>Perl 6 kann auch mit komplexen Zahlen rechnen (wer nicht weiß,
    was das ist: diesen Abschnitt einfach ignorieren). Allerdings ist zu
    beachten, dass Perl 6 kein Computer-Algebra-System ist, d.h. es
    entstehen kleine Fehler beim Rechne.</p>

<pre>[[[syntax perl6]]]
say exp(-1i * pi) + 1;
[[[endsyntax]]]</pre>

    <p>liefert also nicht genau 0, sondern eine sehr kleine, komplexe Zahl.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h4>Strings</h4>

    <p>Strings oder Zeichenketten waren von jeher die Stärke von
    Perl, das hat sich auch in Perl 6 nicht geändert.</p>

    <p>Strings kann man im Quelltext entweder in einfachen
    Anführungszeichen <code>'bla'</code> oder in doppelten
    <code>"bla"</code> angeben.</p>

    <p>Der Unterschied ist, dass Strings in doppelten
    Anführungszeichen "interpoliert" werden, d.h. andere Variablen
    werden durch ihren Wert ersetzt:</p>

<pre>[[[syntax perl6]]]
my $age = 18;
say "In Deutschland wird man mit $age volljährig.";
# gibt folgendes aus:
# `In Deutschland wird man mit 18 volljährig.' (ohne die
# Anführungszeichen)

say 'In Deutschland wird man mit $age volljährig.';
# gibt folgendes aus:
# `In Deutschland wird man mit $age volljährig.'
[[[endsyntax]]]</pre>

    <p>Zwei Strings können mit einer Tilde <code>~</code> miteinander
    verbunden werden (Konkatenation):</p>

<pre>[[[syntax perl6]]]
say "Hallo" ~ " " ~ "Welt";
[[[endsyntax]]]</pre>

    <p>Aus Strings kann man andere Strings mit <code>substr</code> 
    ausschneiden:</p> 

<pre>[[[syntax perl6]]]
use v6;
my $alphabet = ("a" .. "z").join;
say $alphabet;              # `abcdefghijklmnopqrstuvwxyz'
say $alphabet.substr(2);    # alles ab dem 3. Zeichen, also
                            #`cdefghijklmnopqrstuvwxyz' 

say $alphabet.substr(2, 5); # Fünf Zeichen ab dem 3. Zeichen, also `cdefg'

# negative Indizes werden von hinten gezählt, mit dem letzen Element als
# -1; sie müssen mit einem * gekennzeichnet werden:
say $alphabet.substr(2, *-2);  # Alles ausser den ersten beiden und den letzten
# beiden Zeichen, also `cdefghijklmnopqrstuvwx'
[[[endsyntax]]]
</pre>
    <p>Das erste Zeichen eines Strings hat den Index 0.</p>

    <p>Man kann mit <code>substr</code> auch Text ersetzen:</p>

<pre>[[[syntax perl6]]]
$alphabet.substr(1, *-1) = " bis ";
say $alphabet;
# gibt `a bis z' aus
[[[endsyntax]]]</pre>

    <p>Strings kann man sehr leicht an bestimmten Stellen, zum Beispiel an
    bestimmten Zeichen, aufbrechen:</p>

<pre>[[[syntax perl6]]]
my $s = "Der weite Weg";
$s.split; # Ohne Argument spaltet split an Leerzeichen:
# ("Der", "weite", "Weg")

$s.split("e"); # mit Argument wird nach dem Argument gespalten:
# ("D", "r w", "it", " W", "g")
[[[endsyntax]]]</pre>

    <p><code>split</code> liefert eine Liste zurück, dazu später
    mehr.</p>

    <p>Mit <code>split</code> und einer ähnlichen Funktion namens 
    <code>comb</code> kann man Strings auch mit Hilfe von 
    <a href="#rules">regulären Ausdrücken</a> zerlegen, was sehr
    viele Möglichkeiten eröffnet.</p>

      <a class="topOfPage" href="#top" title="Go to top of page">top</a>


    <h3>Arrays und Listen</h3>

    <p>Listen enthalten mehrere Skalare in einer festen Reihenfolge.</p>
    
    <p>Die Variablen, in denen Listen gespeichert werden, heissen Arrays. Ihr
    Name beginnt mit dem Sigil <code>@</code>.</p>

    <p>Wie Strings sind auch Arrays 0-indiziert, d.h. das erste Element
    hat den Index 0:</p>

<pre>[[[syntax perl6]]]
my @weekdays = "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag";
# Zugriff auf einzelne Elemente:
say @weekdays[0]; # `Montag'

say @weekdays.join(", ")
# `Montag, Dienstag, Mittwoch, Donnerstag, Freitag'

say @weekdays.elems
# 5
[[[endsyntax]]]</pre>

    <p>Es gibt auch eine Kurzschreibweisen, um Arrays zu initialiseren:</p>

<pre>[[[syntax perl6]]]
my @weekdays = <Montag Dienstag Mittwoch Donnerstag Freitag> 
# trennt am Leerzeichen

my @digits = 0 .. 9  # selbsterklärend
my @letters = "a" .. "z", "A" .. "Z"  # ebenso ;-) 
[[[endsyntax]]]</pre>

    <p>Aus Listen kann man sich aus Teillisten extrahieren ("Array
    Slices"):</p>
<pre>[[[syntax perl6]]]
my @a = 'A' .. 'Z';
say @a[0 .. 4];
# `ABCDE'
say @a[0, -1];
# `AZ'

# In Array Slices kann man auch schreiben:
@a[1 .. 24] = " bis ";
say @a;
# `A bis Z'
[[[endsyntax]]]</pre>

    <p>Die Elemente, die durch das Schreiben in eine Array Slice
    gelöscht werden, verschwinden nicht, sondern werden durch
    <code>undef</code>, also einen leeren Wert, ersetzt.</p>

<p>Für den Zugriff und das Ändern des ersten und letzten Element gibt es eigene
Funktionen, weil es so häufig gebraucht wird:</p>

<pre>[[[syntax perl6]]]
# push fügt hinten an, pop entfernt das letzte Element
my @a = 1, 2;
@a.push(3);
# @a ist jetzt 1, 2, 3
say @a.pop;
# gibt `3' aus, @a ist danach wieder 1, 2

# unshift fügt vorne an, shift entfernt das erste Element
@a.unshift(0);
# @a ist jetzt 0, 1, 2, 3
say @a.shift;
# gibt `0' aus, @a ist danach (1, 2, 3)
[[[endsyntax]]]</pre>

    <p>Listen sind interpolierend, d.h. das einfügen von Listen in
    andere Listen erzeugt keine verschachtelten Listen:</p>

<pre>[[[syntax perl6]]]
my @a = 1, 2;
my @b = 0, @a, 3;
say @b.elems;
# `4'
[[[endsyntax]]]</pre>

    <p>Um verschachtelte Listen zu bekommen, darf man keine Arrays
    einfügen, sondern <strong>Captures</strong> (Referenzen) zu Arrays.</p>

    <p>Das erreicht man in Perl durch einen Rückstrich
    <code>\</code>.</p>
<pre>[[[syntax perl6]]]
my @a = 1, 2;
my @b = 0, \@a, 3;
say @b.elems;
# `3'

# oder kürzer:
@b = 0, [1, 2], 3;
[[[endsyntax]]]</pre>

    <p>Die Kurzschreibweise für Arrayreferenzen sind eckige
    Klammern: <code>[1 .. 4]</code>.</p>

    <p>Auf verschachtelte Arrays kann man mit mehrfachen eckigen Klammern
    hintereinander zugreifen:</p>

<pre>[[[syntax perl6]]]
my @a = [1, 2, 3], [4, 5, 6], [7, 8, 9];
say @a[0][2];
# `3'
[[[endsyntax]]]</pre>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>Hashes</h3>
    <p>Hashes oder "Assoziative Listen" funktionieren ähnlich wie
    Arrays, aber man greift mit Strings anstatt mit ganzen Zahlen auf die
    ELemente zu. Ihr Sigil ist ein Prozent-Zeichen <code>%</code>. In anderen
    Programmiersprachen heißen sie "dictionaries" oder "maps".</p>

<pre>[[[syntax perl6]]]
my %leader = (
        'USA'           => 'G. W. Bush',
        'Deutschland'   => 'A. Merkel',
        'GB'            => 'G. Brown',
    );

my $country = "USA";
say $country , " wird zur Zeit von %leader{$country} regiert";
# Elemente im Nachhinein ändern oder hinzufügen:
%leader{'Transsylvanien'} = 'Dracula';
[[[endsyntax]]]</pre>

    <p>Die Reihenfolge, in der die Elemente eingefügt werden, geht
    dabei verloren.</p>

    <p>Pro Schlüssel gibt es genau einen Wert. Wenn man dem
    Schlüssel einen neuen Wert zuweist, wird der alte ersetzt.</p>

    <p>Will man mehrere Werte pro Schlüssel speichern, so muss man in
    den Hash eine Liste schreiben:</p>

<pre>[[[syntax perl6]]]
my %regie = (
        'Steven Spielberg' => ['Die Vögel', 'München', 'Psycho'],
        'Alfred Hitchcock' => ['The Kid', 'Goldrausch'],
    );
my $regisseur = "Alfred Hitchcok";
say $regisseur, " hat folgende Filme gedreht: ", %regie{$regisseur}.join(", ");
[[[endsyntax]]]</pre>

    <p>Auf alle Schlüssel eines Hashs <code>%h</code> kann man mit
    <code>%h.keys</code> zugreifen, <code>%h.values</code> gibt alle Werte
    zurück. Wie man elegant alle Elemente eines Hashes durchlaufen
    kann, steht im Abschnitt <a href="#for">über for-Schleifen</a>.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h2>Kontrollstrukturen</h2>
        
    <h3>If-Else</h3>

    <p>Verzweigungen im Programmtext funktionieren mit der <code>if ..
    elsif ..  else</code>-Konstruktion:</p>

<pre>[[[syntax perl6]]]
if $age < 6 {
    say "Du bist noch nicht mal in der Schule"
} elsif 11 <= $age <= 16 {
    say "Pubertaet..."
} else {
    say "Irgendwer..."
}
[[[endsyntax]]]</pre>

    <p>Der <code>elsif</code> und <code>else</code>-Block können
    weggelassen werden, und es können beliebig viele
    <code>elsif</code>-Blöcke vorkommen.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3 id="for">for: Über Listen iterieren</h3>

    <p>Häufig muss man alle Elemente einer Liste durchlaufen. Das
    geht mit der <code>for</code>-"Schleife":</p>

<pre>[[[syntax perl6]]]
my @a = <Montag Dienstag Mittwoch Donnerstag Freitag>;
for @a -> $day {
    say $d, "s frueh aufstehen..."
}
say "Immer das gleiche!";
[[[endsyntax]]]</pre>

    <p>Gibt als Ausgabe:</p>
<pre>
Montags frueh aufstehen...
Dienstags frueh aufstehen...
Mittwochs frueh aufstehen...
Donnerstags frueh aufstehen...
Freitags frueh aufstehen...
Immer das gleiche!
</pre>

    <p>Bei jedem Durchlauf der Schleife wird <code>$day</code> auf einen
    Wert des Arrays gesetzt.</p>

    <p>Wenn man die Angabe der Variable, in der der Wert gespeichert
    werden soll, weglässt, so wird der Wert in der speziellen
    Variable <code>$_</code> gespeichert:</p>

<pre>[[[syntax perl6]]]
my @a = <Montag Dienstag Mittwoch Donnerstag Freitag>;
for @a {
    say $_, "s frueh aufstehen..."
}
say "Immer das gleiche!";
[[[endsyntax]]]</pre>
    <p>Auch Hashes kann man damit durchlaufen:</p>

<pre>[[[syntax perl6]]]
my %essen = (
        'Schwaben'  => 'Maultaschen',
        'Bayern'    => 'Weisswuerste',
        'Briten'    => 'Fish & Chips',
    );
for %essen.kv -> $leute, $gericht {
    say "Die $leute essen gerne $gericht";
}[[[endsyntax]]]</pre>

    <p>Man beachte, dass die Elemente aus einem Hash in zufälliger
    Reihenfolge herauskommen. Wenn man das nicht möchte, kann man
    die keys vorher sortieren:</p>

<pre>[[[syntax perl6]]]
my %essen = (
        'Schwaben'  => 'Maultaschen',
        'Bayern'    => 'Weisswuerste',
        'Briten'    => 'Fish & Chips',
        );
for %essen.keys.sort -> $leute {
    say "Die $leute essen gerne" ~ %essen{$leute};
}[[[endsyntax]]]</pre>

      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>loop - Schleifen</h3>

    <p>Was in anderen Sprachen (C, C++, Java, Perl5 ...) die
    <code>for</code>-Schleife ist, ist in Perl 6 die
    <code>loop</code>-Schleife:</p>

<pre>[[[syntax perl6]]]
loop (my $i = 2; $i < 300; $i **= 2){ 
    say $i
}
# Ausgabe:
# 2
# 4
# 16
# 256
[[[endsyntax]]]</pre>

    <p>(<code>$i **= 2</code> ist kurz für <code>$i = $i**2</code>,
    d.h. bei jedem Ausführen wird $i quadriert.)</p>

    <p><code>loop</code> ist wie folgt aufgebaut: <code>loop(init;
    bedingung; increment){ code }</code>. Ganz am Anfang wird einmal die
    Anweisung in <code>init</code> ausgeführt. Dann wird die
    <code>bedingung</code> geprüft. Wenn sie wahr ist, wird
    <code>code</code> ausgeführt, und dann <code>increment</code>.
    Dann wird wieder die Bedingung geprüft, und so weiter.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>While-Schleife</h3>

    <p>Wie fast jede Programmiersprache hat auch perl6 eine
    <code>while</code>-Schleife:</p>

<pre>[[[syntax perl6]]]
use v6;
my $val = 100;
my $w = 1;
my $eps = 1e-7;

# berechne iterativ die Wurzel von $val:
while abs($w*$w-$val) > $eps {
    $w = 0.5 * ($w + $val / $w );
}
say $w;
#Ausgabe: 10.00000000013989
[[[endsyntax]]]</pre>
    <p>Die <code>while</code>-Schleife wird augeführt, solange die
    Bedingung direkt hinter dem <code>while</code> wahr ist.</p>

    <p>Wenn die Bedingung von Anfang an nicht erfüllt ist, wir die
    Schleife kein einziges mal ausgeführt.</p>

    <p>Diese Schleife rechnet Nährungsweise die Wurzel von
    <code>$val</code> aus (es gibt natürlich auch eine eingebaute
    Funtkion die das macht, <code>sqrt()</code>.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>Eigene Funktionen</h3>

    <p>Eigene Funktionen kann man mit <code>sub</code>-Schlüsselwort
    schreiben:</p>

<pre>[[[syntax perl6]]]
sub factorial($x){
    return [*] (1 .. $x);
    # [*] @liste liefert das Produkt aller Elemente der Liste
}
say factorial(3);
# Ausgabe: `6'
[[[endsyntax]]]</pre>

    <p>In den runden Klammern hinter dem Funktionsnamen stehen die
    erwarteten Argumente. Wie bei "normalen" Variablen auch kann man den
    Typ mit angeben:</p>

<pre>[[[syntax perl6]]]
sub factorial(Int $x){
    return [*] (1 .. $x);
}
[[[endsyntax]]]</pre>

    <p>Und man kann auch den Rückgabetyp festlegen:</p>
<pre>[[[syntax perl6]]]
sub factorial(Int $x) returns Int {
    return [*] (1 .. $x);
}

# oder anders geschrieben:

sub factorial(Int $x --> Int){
    return [*] (1 .. $x);
}
[[[endsyntax]]]</pre>

    <p>Wie in Perl 5 kann man die Argumenteliste bei der Definition der
    Funktion auch weglassen, übergebene Argumente landen in der
    speziellen Variable <code>@_</code>:</p>

<pre>[[[syntax perl6]]]
sub factorial {
    return [*] (1 .. @_[0]);
}
[[[endsyntax]]]</pre>

    <p>Eine Funktion kann auch Listen zurückgeben. Innerhalb einer
    Funktion kann man mit dem Objekt <code>want</code> abfragen, ob der
    Aufrufer eine Liste, einen Hash oder ein einzelnes Element
    erwartet.</p>

<pre>[[[syntax perl6]]]
sub wisdom {
    my @w = "Besser nie als spät",
       "Stoßstange ist aller Laster Anfang";
    if (want.List){
        return @w;
    } else {
        return "Wenn du zuhören würdest, hätte ich "
            ~ @w.elems ~ "Weisheiten für dich";
    }
}
[[[endsyntax]]]</pre>

    <p>Parameter werden per Default als read-only Referenzen
    übergeben, d.h. die Funktion kann die Parameter nicht
    verändern. Das kann man mit dem Trait <code>is rw</code>
    ändern:</p>

<pre>[[[syntax perl6]]]
sub swap($x is rw, $y is rw){
    ($x, $y) = ($y, $x);
}
# vertauscht die beiden übergebenen Argumente
[[[endsyntax]]]</pre>

    <p>Wenn man innerhalb der Funktion die Argumente ändern will, ohne
    dass sich diese Änderung ausserhalb der Funktion auswirken, so kann man
    das mit <code>is copy</code> erreichen:</p>

<!-- TODO: besseres Beispiel -->
<pre>[% syntax perl6 %]
my $a = 1;
foo($a);
say $a;     # Ausgabe: 1

sub foo($x is copy) {
    $x = 2;
}
[% endsyntax %]</pre>

      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h4>Multi subs</h4>

    <p>Multi subs funktionieren ähnlich wie überladene Funktionen in
    anderen Programmiersprachen. Mehrere Multi subs haben den gleichen
    Namen, aber unterschiedliche Signaturen:</p>

<pre>[[[syntax perl6]]]
multi foo(Str $x){
    # ... Behandlung für Strings
}
multi foo(Int $x){
    # Behandlung für ganze Zahlen
}
[[[endsyntax]]]</pre>

    <p>Beim Aufruf mit <code>foo($variable)</code> wird anhand des Typs von
    <code>$variable</code> entschieden, welche der Funktionen aufgerufen
    wird.</p>

      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h4>Traits</h4>

    <p>Mit Traits, zu Deutsch "Eigenschaften" oder "Merkmale", 
    kann man das Verhalten von Funktionen modifzieren. Ein 
    Beispiel sind Vorbedingungen für die
    Ausführung einer Funktion, und Zusicherungen, die nach dem
    Ausführen einer Funktion gelten sollen:</p>

<pre>[[[syntax perl6]]]
sub wurzel(Num $x){
    PRE {
        $x >= 0;
    }
    my $w = $x / 2;
    while abs($w * $w - $x) > 1e-8 {
        $w = 0.5 * ($w + $val / $w );
    }

    POST {
        abs($x - $w * $w) <= 1e-8;
    }
}
[[[endsyntax]]]</pre>

    <p>In diesem Beispiel wird eine einfache Wurzel-Funktion geschrieben,
    die als Vorbedingung <code>PRE</code> hat, dass das Argument nicht
    negativ sein darf. Wird <code>wurzel</code> mit einer negativen Zahl
    aufgerufen, wird das Programm mit einer Fehlermeldung abgebrochen.</p>

    <p>Analog dazu ist der <code>POST</code>-Block eine Zusicherung an den
    Aufrufenden, dass die Wurzel mit einer Genauigkeit von mindestens
    1*10<sup>-8</sup> berechnet wurde.</p>

    <p>Mehr zu Traits gibt es in der <a
    href="http://perlcabal.org/syn/S06.html">offziellen
    Perl 6-Dokumentation (Englisch)</a>.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>


    <h2 id="rules">Reguläre Ausdrücke / Rules</h2>

    <p>Ein Wort zu den Namen: Reguläre Ausdrücke, auf Englisch
    "Regular Expressions", sind ein bekanntes Konzept in der Informatik.
    Schon in Perl5 konnten die Regulären Ausdrücke mehr, als die
    Definition der Informatiker erlaubt, deswegen spricht man bei Perl von
    regexes, Singular regex. In Perl 6 können sie noch mehr (für Informatiker:
    sie entsprechen eher den Kontextfreien Sprachen), man nennt sie meistens
    <em>Rules</em>. Hier wird eine wilde Mischung dieser Begriffe gebraucht.</p>

    <p>Reguläre Ausdrücke definieren Muster. Man kann den
    Interpreter anweisen, zu übeprüfen, ob ein Muster zu einer
    Zeichenkette passt.</p>

    <p>Ein paar Beispiele erleutern das:</p>
<pre>[[[syntax perl6]]]
my $test_string = "Larry Wall hat Perl erfunden";

if $test_string ~~ m/ll/ {
    say 'Der Teststring enthält ein Doppel-l';
}

if $test_string ~~ m/ar+y/ {
    say 'Der Teststring enthält ein a, mindestens ein r und dann ein y';
}
[[[endsyntax]]]</pre>

    <p>Einzelne Buchstaben, Ziffern, Minus <code>-</code> und Unterstrich
    <code>_</code> haben keine besondere Bedeutung, sondern stehen
    für das jeweilige Zeichen.</p>

    <p>Sonderzeichen wie ()[]{}+*? beraubt man ihrere besondern Bedeutung,
    indem man ihnen eine Backslash <code>\</code> voranstellt.</p>

    <p>Leerzeichen innerhalb von Regexes werden ignoriert.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>Alternativen</h3>

    <p>Ein senkrechter Strich <code>|</code> steht für ein logisches
    Oder. <code>m/Ein(horn|stein)/</code> passt also auf Einhorn und
    Einstein.</p>

    <h3>Verankerung</h3>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <p>Wenn man eine regex auf einen String anwendet, passt sie, wenn
    irgend ein Teilstring auf die regex passt. Wenn man sie explizit an
    den Anfang oder das Ende eines Strings verankern will, kann man das
    mit <code>^</code> und <code>$</code> erreichen:</p>

<pre> [[[syntax perl6]]]
m/^GenaudieseZeile$/
# passt auf
[[[endsyntax]]]</pre>

    <p>Wenn ein String mehrere logische Zeilen enthält, kann man auf
    Anfang und Ende einer Zeile mit <code>^^</code> und <code>$$</code>
    überprüfen.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>Quantoren</h3>

    <p>Quantoren sind Sonderzeichen, die angeben, wie häufig das vorhergehende
    Zeichen wiederholt werden kann.</p>

    <p>Wenn hinter einem Buchstaben (oder einer Klammer) ein Fragezeichen
    <code>?</code> kommt, so ist dieser Buchstaben optional.</p>

    <p><code>m/mi?au/</code> passt also auf miau oder auf mau.</p>

    <p>Das Plus <code>+</code> steht für eine oder beliebig viele
    Wiederholungen. <code>m/mi+au/</code> matched also miau, miiau, miiiau
    usw, aber nicht mau.</p>

    <p>Der Stern <code>*</code> steht für keine oder beliebig viele
    Wiederholungen. <code>m/mi*au/</code> matched also mau, miau, miiau,
    miiiau etc.</p>

    <p>Man kann auch explizit eine gewünschte Anzahl von
    Wiederholungen angeben: <code>m/ab**{3}c/</code> matched abbbc,
    <code>m/ab**{3 .. 8}c/</code> matched ein a, gefolgt von 3 bis 8 b's und
    einem c.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>Zeichenklassen</h3>

    <p>Bisher waren die regexes relativ langweilig. Durch Zeichenklassen
    werden sie sehr viel mächtiger. Eine Zeichenklassen entspricht 
    einer (meistens recht langen) Auflistung von durch <code>|</code>
    getrennten Zeichen, und matched immer genau ein Zeichen</p>

    <table summary="Charakterklassen von Perl 6-regexes">
    <tr><th>Symbol</th><th>Bedeutung</th></tr>
    <tr><td>.</td><td>Beliebiges Zeichen</td></tr>
    <tr><td>\s</td><td>Whitespaces, also Leerzeichen, Tabs,
    Zeilenumbruch</td></tr>
    <tr><td>\S</td><td>Alles ausser Whitespaces</td></tr>
    <tr><td>&lt;sp&gt;</td><td>Ein Leerzeichen</td></tr>
    <tr><td>\d</td><td>Eine Ziffer</td></tr>
    <tr><td>\D</td><td>Alles ausser einer Ziffer</td></tr>
    <tr><td>\w</td><td>Ein Buchstabe</td></tr>
    <tr><td>\W</td><td>Alles ausser einem Buchstaben</td></tr>
    <tr><td>\n</td><td>Ein Zeilenumbruch</td></tr>
    <tr><td>\N</td><td>Alle außer einem Zeilenumbruch</td></tr>
    <tr><td>&lt;alpha&gt;</td><td>Buchstabe (alternative Schreibweise)</td></tr>
    <tr><td>&lt;digit&gt;</td><td>Ziffer (alternative Schreibweise)</td></tr>
    </table>

    <p>Man beachte dabei, dass "Buchtstabe" nicht nur A bis Z meint, sondern
    auch Buchstaben in anderen Sprachen. (Entspricht der Unicode-Eigenschaft
    <code>Letter</code>).</p>

    <p>Wenn man eine ganze Zahl, gefolgt von einem oder mehr Leerzeichen
    und einem Wort finden will, kann man das mit folgender Regex
    machen:</p>

<pre>[[[syntax perl6]]]
my $text = "Du schuldest mir 20 Euro";
if $text ~~ m/\d+\s+\w+/ {
    say "Aha,  $/";
}
# Ausgabe: 'Aha, 20 Euro'
[[[endsyntax]]]</pre>

    <p>In diesem Beispiel wird die spezielle Variable <code>$/</code>
    verwendet, die, wenn sie als String verwendet wird, den gematched Text
    zurückliefert.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>Capturing Groups</h3>

    <p>Wenn man einen Teil einer regex in runde Klammern <code>()</code>
    einschliesst, merkt sich der Interpreter den String, der auf die
    Teilregex innerhalb der Klammern gepasst hat.</p>

    <p>Später innerhalb der regex kann man dann mit der Variable
    <code>$0</code> auf den Inhalt der ersten Klammer zugreifen, mit
    <code>$1</code> auf den Inhalt der zweiten usw. Außerdem kann
    man <code>$/</code> als Array verwenden, und auf das
    <code>$n</code>-te Element zugreifen: <code>$/[0]</code>,
    <code>$/[1]</code> usw.</p>

    <p>Damit kann man z.B. nach wiederkehrenden Mustern suchen.
    Angenommen, man will ganz einfaches HTML darauf untersuchen, ob die
    Tags richtig verschachtelt sind. Richtig wäre z.B:</p>
<pre>[[[syntax html]]]
Bla bla bla <strong>fetter Text</strong> bla
bla
[[[endsyntax]]]
</pre>

    <p>Und falsches HTML wäre</p>

<pre>[[[syntax html]]]
Bla bla bla <strong>fetter Text</em> bla
bla
[[[endsyntax]]]</pre>
[[[comment damit das Syntax-hilighting nicht verrückt spielt: </strong>]]]

    <p>weil ein <code>&lt;strong&gt;</code>-Tag durch ein <code>&lt;em&gt;</code>-Tag
    geschlossen wird.</p>

    <p>Und so kann man nach korrekten Tags suchen:</p>

<pre> [[[syntax perl6]]]
my $text = 'Bla bla bla <strong>fetter Text</strong> bla bla';

if $text ~~ m/ \<(\w+)\> (.*) \<\/$0> / {
    say "Matched tag $0 with content '$1'";
}
#Ausgabe: Matched tag strong with content 'fetter Text'
[[[endsyntax]]]</pre>

    <p>Wenn man den Inhalt einer Klammer nicht braucht, d.h. wenn man die
    Klammer nur braucht, um zu gruppieren, kann man eckige Klammern
    <code>[...]</code> anstatt runder Klammern verwenden.</p>

    <p>Über Regexes kann man ganze Bücher schreiben, und in der
    Tat <a
    href="http://www.amazon.de/gp/product/0596528124?ie=UTF8;tag=moritzlenz-21;linkCode=as2;camp=1638;creative=6742;creativeASIN=0596528124">gibt
    es auch sehr gute Bücher darüber</a>.</p>

    <p>Gerade mit den Regexes von Perl 6 hat man noch sehr, sehr viel mehr
    Möglichkeiten, als bisher beschrieben.</p>

    <p>Mehr dazu gibt es in dem <a
    href="/tutorials/regex">Regex-Tutorial</a>.</p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

      <h3>Benannte Rules</h3>

      <p>Man kann Rules Namen geben, unter denen man sie ansprechen und in
      andere Rules einbauen kann:</p>

<pre>[[[syntax perl6]]]
token sigil { \$ | @ | % };
token twigil { \. | ! | \? | \* };
token identifier { <[a-zA-Z_0-9]> };
regex perl6_variable { <sigil> <twigil>? <identifier> };
[[[endsyntax]]]</pre>
    <p>Das ist ein krudes Modell, um Perl 6-Variablen aufzufinden, die aus
    einem Sigil (<code>$</code> für Skalare, <code>@</code> für
    Arrays...), einem optionalen Twigil und dem eigentlichen Namen der
    Variablen.</p>

    <p>Es demonstriert, wie man Rules mit dem Schlüsselwörtern
    <code>token</code> und <code>regex</code> Namen geben kann, und dann mit
    <code>&lt;name_der_rule&gt;</code> angesprochen werden kann.</p>

    <p>Der Unterschied zwischen <code>token</code> und <code>regex</code>
    ist, dass in einem <code>token</code> kein Backtracking stattfindet,
    was die mögliche Komplexität einschränkt.</p>

    <p>Damit kann man ganze Grammatiken aufbauen und mit rules
    überprüfen.</p>

      <h3>Rules anwenden</h3>

      <p>Die einfachste Möglichkeit, eine regexp/rule anzuwenden, ist der
      "Smart Match Operator" <code>~~</code>.</p>

<pre>[[[syntax perl6]]]
my $match = "abcd" ~~ m/b(c)/
[[[endsyntax]]]</pre>

    <p>in <code>$match</code> wird ein <code>Match</code>-Objekt
    gespeichert. Diese Objekt verhält sich, je nach Kontext,
    unterschiedlich:</p>

<pre> [[[syntax perl6]]]
say $match;
# liefert `bc', also den Text, auf den die Regexp passt
say $match[0];
# liefert `c', also den Text, auf den die erste Gruppe in runden Klammern
# gepasst hat
say $match.from, " ", $match.to;
# liefert `1 3', also Anfangs- und Endposition des Matches
if ($match){
    # Im logik-Kontext (True/False) wird True zurückgegeben,
    # wenn die rexep auf den String gepasst hat
    ...
}
[[[endsyntax]]]</pre>

    <p>Man kann auch mit regexes/rules Text ersetzen:</p>

<pre>[[[syntax perl6]]]
my $text = "foo 123 bar 42";
$text ~~ s/^f../blubb/;
# $text enthält jetzt "blubb 123 bar 42"

# jede Zahl im String verdoppeln:

$text ~~ s:g[(\d+)] = 2 * $0;
# das :g sorgt dafür, dass alle Vorkommnisse der Regex 
# ersetzt werden (g = global)

say $text;
# blubb 246 bar 84
[[[endsyntax]]]</pre>


    <h2>Input/Output</h2>

    <p>Die Ausgabe auf den Bildschirm, d.h. auf die Standardausgabe des
    Programms, erfolt mit <code>say</code> oder <code>print</code>. Der
    Unterschied besteht darin, dass <code>say</code> am Ende einen
    zusätzlichen Zeilenumbruch ausgibt, <code>print</code> nicht.</p>

<pre>[[[syntax perl6]]]
print "Text";
print ", und mehr Text\n";
# liefert `Text, und mehr Text' und dann einen Zeilenumbruch, d.h. die
# nächste Ausgabe findet auf der nächsten Zeile statt.
[[[endsyntax]]]</pre>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>In Dateien schreiben </h3>
    <p>Ausgabe in Dateien ist auch nicht viel schwerer:</p>

<pre>[[[syntax perl6]]]
my $filename = "/path/to/file"
my $f = open($filename, :w) err die "Can't open $filename: $!";
say $f: "Dieser Text landet in der Datei $filename";
$f.say: "Dieser Text auch";
$f.close();
[[[endsyntax]]]</pre>

    <p>Mit <code>open</code> wird eine Datei geöffnet, das zweite
    Argument <code>:w</code> gibt an, dass die Datei zum schreiben
    geöffent wird. Dabei wird sie, falls sie existiert,
    überschrieben. Wenn man das nicht will, kann man sie mit
    <code>:a</code> öffnen, dann wird alles, was hineingeschrieben
    wird, ans Ende angehängt.</p>

    <p><code>open()</code> liefert ein filehandle zurück, dass man in
    einem Skalar speichern kann, hier <code>$f</code>.</p>

    <p>Mit der Konstruktion <code>open(..) err die "..."</code> wird im
    Fehlerfall die Funktion <code>die</code> ausgeführt, die das
    Programm mit einer Fehlermeldung beendet.</p>

    <p>Man kann, wie oben im Beispiel, <code>say</code> und
    <code>print</code> als erstes Argument ein Filehandle mitgeben,
    gefolgt von einem Doppelpunkt <code>:</code>, um die Ausgabe in diese
    Datei umzuleiten.</p>

    <p>In jedem Programm gibt es die globalen Variablen
    <code>$*IN</code> (default input oder stdin), 
    <code>$*OUT</code> (default output oder stdout) und 
    <code>$*ERR</code> (default error output oder stderr). (Man beachte
    den Stern <code>*</code> nach dem Sigil, ein sogenanntes "secondary
    sigil" oder "twigil", das alle globalen Variablen haben). </p>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

    <h3>Aus Dateien / von der Standardausgabe lesen</h3>

    <p>Wenn man ein Filehandle hat, kann man daraus mittels
    <code>readline()</code> zeilenweise lesen, oder mit
    <code>getc()</code> zeichenweise. Mit <code>slurp</code> kann man den
    gesamten Inhalt auslesen.</p>

<pre>[[[syntax perl6]]]
# lese durch beliebige Zeichen getrennte ganze Zahlen von der 
# Standardeingabe ein  und gebe die Summe aus:
for =<> -> my $line {
    # comb liefert alle Matches der Regular Expression zurück:
    my @numbers = $line.comb(/\d+/);
    # [+] (liste) gibt die Summe aller Elemente der Liste
    say [+] @numbers;
}
[[[endsyntax]]]</pre>

    <p>Um aus einer Datei zu lesen, öffnet man sie vorher mit
    <code>open</code>, und list mit der Konstruktion <code>=$fh</code>:</p>
<pre>[[[syntax perl6]]]
my $f = open("summe.dat") err die "Kann summe.dat nicht lesen: $!";
for =$f -> $line {
    my @numbers = $line.comb(/\d+/);
    say [+] @numbers;
    # [+] (liste) gibt die Summe aller Elemente der Liste
} 
[[[endsyntax]]]</pre>
      <a class="topOfPage" href="#top" title="Go to top of page">top</a>

      <h2>Objektorientierung: Klassen, Rollen und Objekte</h2>

      <p>Perl 6 bietet die Möglichkeit, objektorientiert zu programmieren.
      Allerdings ist das vollkommen optional, wenn man nicht will, muss man
      auch nicht.</p>

      <p>Das Objektmodell von Perl 6 ist ausführlich <a
      href="/tutorials/objektmodell">hier</a> beschrieben.</p>


    <h2>Funktionen</h2>

    <p>Perl 6 bring von sich aus viele nützliche Funktionen mit. Hier
    seien nur ein paar wichtige erwähnt, die komplette Liste
    inklusive Erklärungen gibt es in der offiziellen Dokumentation im
    Abschnitt <a href="http://perlcabal.org/syn/S29.html">builtin
    functions</a>.</p>

      <a class="topOfPage" href="#top" title="Go to top of page">top</a>
    <h3>Mathematische Funktionen</h3>

    <p>Die "üblichen" mathematischen Funktionen sind in Perl 6
    verfügbar:</p>

    <p><code>abs</code> (Betrag), <code>floor, ceiling, round</code>
    (Runden), <code>sin, cos, tan, asin, acos, atan, sec, cosec, cotan,
    asec, acosec, acotan, sinh, cosh, tanh, asinh, acosh, atanh, sech,
    cosech, cotanh, asech, acosech, acotanh</code> (Trigonometrische
    Funktionen, <code>sec</code> ist <code>1/sin</code>, <code>exp, log,
    log10</code> (Exponent und Logarithmen), <code>rand</code>
    (Zufallszahlen), <code>sqrt, roots</code> (Wurzel und
    <code>n</code>-te komplexe Wurzeln) und <code>sign</code>
    (Vorzeichen).</p>

    <h3>Listen-Behandlung</h3>
    <p><code>push</code>, <code>pop</code>, <code>shift</code> und
    <code>unshift</code> fügen an Anfang und Ende eines Arrays Elemente
    hinzu und entfernen sie:</p>

<pre>[[[syntax perl6]]]
my @a = 1, 2, 3, 4, 5;

my $b = @a.shift;
# $b enthält 1, @a = (2, 3, 4, 5);

@a.unshift(7);
# @a ist jetzt (7, 2, 3, 4, 5)

my $last =  @a.pop;
# @a ist (7, 2, 3, 4), $last ist 5

@a.push(23, 42);
# @a ist jetzt (7, 2, 3, 4, 23, 42)
[[[endsyntax]]]</pre>

    <p><code>splice</code> entfernt Elemente aus einem Array, und fügt
    optional welche an. Der erste Parameter für <code>splice</code> ist
    die Position, der zweite die Länge, der dritte (optional) die neuen
    Elemente:</p>
<pre>[[[syntax perl6]]]
my @a = 1 .. 4;
my @b = @s.splice(1, 2);
# @b = (2, 3); @a = 1, 4;

@a.splice(1, 0, @b);
# @a ist wieder (1, 2, 3, 4); 0 Elemente ersetzen ist wie Elemente einfügen
[[[endsyntax]]]</pre>

    <p><code>grep</code> liefert die Elemente einer Liste, die einer
    bestimmten Bedinung genügen:</p>
    
<pre>[[[syntax perl6]]]
my @l = grep { $_ % 3 == 0}, 1 .. 10;
# alle durch drei teilbaren Zahlen, also (3, 6, 9)

#das gleiche:
my @l = grep { $^a % 3 == 0}, 1 .. 10;
[[[endsyntax]]]</pre>
    <p><code>first</code> funktioniert wie <code>grep</code>, nur dass nur
    das erste passende Element zurückgeliefert wird.</p>

    <p><code>pick</code> liefert eine zufällige Auswahl an
    Elementen:</p>

<pre>[[[syntax perl6]]]
(1 .. 10).pick(3)
# (6, 1, 2)
(1 .. 10).pick(3)
# (7, 4, 9)
(1 .. 10).pick(3)
# (3, 5, 10)
[[[endsyntax]]]</pre>

    <p><code>map</code> wendet eine Funktion auf jedes Element einer Liste
    an, die zurückgegebenen Elemente bauen wieder eine Liste auf:</p>

<pre>[[[syntax perl6]]]
# Quadrate berechnen:
(1 .. 10).map( {$_ * $_ })
# (1, 4, 9, 16, 25, 36, 49, 64, 81, 100)
[[[endsyntax]]]</pre>
    <p><code>sort</code> sortiert listen, optional mit einem
    Vergleichs-Block:</p>
<pre>[[[syntax perl6]]]
(1 .. 20).pick(5).sort         
# (1, 2, 6, 15, 18)
(1 .. 20).pick(5).sort
# (5, 6, 15, 16, 19)

# mit einem Vergleichsblock, der explit nach String-Reihenfolge 
# sortiert, d.h. "1" < "10" < "2":
(1 .. 20).sort( {~$^a cmp ~$^b }
# (1, 10, 11, 12 .. 19, 2, 20, 3, 4 .. 9)
[[[endsyntax]]]</pre>
    <p>In dem letzten Beispiel werden dem Vergleichsblock von
    <code>sort</code> zwei Parameter übergeben, die in <code>$^a</code>
    und <code>$^b</code> gespeichert werden.</p>

    <p><code>min</code> und <code>max</code> liefern das kleinste/größte
    Element einer Liste, <code>reverse</code> ergibt die Liste in
    umgekehrte Reihenfolge.</p>



    <h2>Timtowtdi: "There is more than one way to do it"</h2>

    <p>Eine von Perls Philosophien war schon immer, dem Programmierer
    möglichst  viele Freiheiten zu lassen, und ihn damit so
    programmieren lassen, wie ihm oder ihr das am besten gefällt.</p>

    <p>Hier seien ein paar Beispiele aufgefürht, wie man ein paar
    einfache Aufgaben auf verschiedene Arten lösen kann.</p>

    <h3>Alle Werte einer Liste um <code>$n</code> erhöhen</h3>

<pre>[[[syntax perl6]]]
my $n = 3;
my @a = (1, 4, 7, 9);

#mit einer Schleife:
my @b;
for @a -> $i {
    push @b, $i + $n;
}

# oder so, wie man das in C machen würde:
my @c = @a;
loop(my $i = 0; $i < @a.elems; $i++){
    @c[$i] += $n;
}

# Aus funktionalen Programmiersprachen "geklaut":
my @d = map { $_ + $n }, @a;

# Mit Perls Hyperoperatoren:

my @e = @a >>+ $n;
[[[endsyntax]]]</pre>
<!--
    vim: expandtab ts=4 sw=4
-->
