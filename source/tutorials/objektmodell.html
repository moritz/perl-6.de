[[[menu main tut objekt]]]
[[[setvar title Perl 6 Objekte und Klassen]]]

<div id="content">
	<h1>Das Objektmodell von Perl 6</h1>

	<p>Um von dieser Seite profitieren zu können sollten Sie  mit dem
	Grundlagen von Perl 6 vertraut sein, und auch ein wenig von
	Objektorientierung verstehen - Wenn Sie wissen, was eine Klasse, ein
	Objekt und Vererbung ist, reicht das vermutlich schon.</p>

	<p>Das Objektmodell von Perl 6 hat nur noch wenige Ähnlichkeiten mit
	dem von Perl 5, und muß jetzt den vergleich mit "klassischen"
	Objektorientierten Programmiersprachen nicht mehr scheuen.</p>

	<h2>Klassen definieren</h2>

	<p>Klassen werden mit dem <code>class</code>-Schlüsselwort defniert,
	das man auf zwei verschiedene Arten verwenden kann. Entweder als erste
	Anweisung in einer Datei in der Form <code>class Foo;</code>, dann
	ist der Rest der Datei die Defintion der Klasse. Die zweite
	Möglichkeit sieht so aus:</p>
<pre>[[[syntax perl6]]]
class Foo {
	# hier kommt die Definition der Klasse
}
# hier ist die Definition der Klasse zu Ende
[[[endsyntax]]]</pre>

	<p>Objektvariablen werden mit <code>has</code> anstatt <code>my</code>
	deklariert, Funktionen mit <code>method</code> anstatt
	<code>sub</code>:</p>

<pre>[[[syntax perl6]]]
class Rechteck {
	has $breite;
	has $hoehe;

	method flaeche {
		return $breite * $hoehe;
	}
}[[[endsyntax]]]</pre>

	<p>Wenn Objektvariablen von außen lesbar sein sollen, kann man sie mit
	der Schreibweise <code>has $.foo</code> lesbar machen, wenn man sie
	von außen auch setzen können soll hilft ein <code>is rw</code>:</p>

<pre>[[[syntax perl6]]]
class Rechteck {
	has $.breite is rw;
	has $.hoehe is rw;

	method flaeche {
		return $.breite * $.hoehe;
	}
}
my Rechteck $r = Rechteck.new();
$r.breite = 2;
$r.hoehe = 5;
say $r.flaeche();
[[[endsyntax]]]</pre>
	<p>Das ist natürlich noch nicht besonders schön. Angenommen, man
	möchte <code>$.breite</code> und <code>$.hoehe</code> beim erstellen
	eines Objekts initialisieren, und danach nicht mehr ändern können.
	Dann verwendet man den Konstruktur <code>BUILD</code>:</p>

<pre>[[[syntax perl6]]]
class Rechteck {
	has $.breite;
	has $.hoehe;

	submethod BUILD ($.breite, $.hoehe) {}

	method flaeche {
		return $.breite * $.hoehe;
	}
}
my Rechteck $r = Rechteck.new(breite => 2, hoehe => 5);
say $r.flaeche();
[[[endsyntax]]]</pre>

	<p><code>BUILD</code> bringt einen automatischen Konstruktor mit, der
	die beiden Variablen <code>$.breite</code> und <code>$.hoehe</code> im
	erstellen Objekt initialisiert. Die Verwendung von
	<code>submethod</code> anstelle von <code>method</code> verhindert,
	dass der Konstruktor automatisch vererbt wird.</p>

	<p>Wenn <code>BUILD</code> nichts außer der impliziten Zuweisung von
	Objektvariablen macht, kann man die Methode auch weglassen.</p>

	<p>Man kann Variablen auch als explizit privat deklarieren indem man
	ihenen ein Ausrufezeichen als Twigl mitgibt, also <code>has
	$!foo;</code>. Methoden kann man privat machen, indem man sie als
	<code>my method private_methode { ... }</code> deklariert.</p>


	<h2>Vererbung</h2>

	<p>Vererbung wird durch das <code>is</code>-Schlüsselwort
	deklariert:</p>

<pre>[[[syntax perl6]]]
class Form {
	...
}

class Rechteck is Form {
	...
}
[[[endsyntax]]]</pre>

	<p>Auch Mehrfachvererbung ist möglich:</p>

<pre>[[[syntax perl6]]]
class Kraftfahrzeug {
	...
}

class Wasserfahrzeug {
	...
}

class Amphibienfahrzeug is Kraftfahrzeug is Wasserfahrzeug {
	...
}
[[[endsyntax]]]</pre>
	<p>(Beispiel aus der <a
			href="http://de.wikipedia.org/wiki/Vererbung_(Programmierung)#Beispiel">Wikipedia</a>)</p>

	<p>Vererbung und andere <code>is ...</code>-Traits kann man auch
	innerhalb der Klasse schreiben:</p>
<pre>[[[syntax perl6]]]

class Amphibienfahrzeug {
	is Kraftfahrzeug;
	is Wasserfahrzeug;
	...
}
[[[endsyntax]]]</pre>

	<h2>Klassen erweitern</h2>

	<p>Wenn man eine Klasse erweitern will, ihr zum Beispiel eine Methode
	hinzufügen will, kann man das auch ohne Vererbung erreichen:</p>

<pre>[[[syntax perl6]]]
class String is also {
	method as_ebcdic {
		...
	}
}
[[[endsyntax]]]</pre>

	<p>Das hat den Vorteil, dass man auch fest eingebaute Datentypen wie
	String oder Int erweitern kann, und fremder Code, den man einbindet,
	verwendet automatisch die erweiterte Version.</p>
	
	<p>Wenn man versucht, eine Klasse zu erweitern, ohne ein <code>is
	also</code> in die Deklaration zu schreiben, bekommt man eine
	Fehlermeldung, dass man eine Klasse redeklariert.</p>


	<h2>Roles</h2>

	<p>In Perl 6 sind Klassen vor allem dazu da, um "ist-ein"-Beziehungen
	für Typen zu deklarieren. Für die Wiederverwendbarkeit von Code sind
	<em>Roles</em>, auf Deutsch <em>Rolle</em> zuständig. Roles sind so 
	etwas wie Interfaces in Java,
	die Implementierung der Methoden beinhalten.</p>

	<p>Genauer gesagt kann eine Role alles enthalten, was eine Klasse auch
	enthalten kann, nur kann man keine Objekte einer Role erstellen.</p>
<pre>[[[syntax perl6]]]
role Haustier {
	has $.halsband;
	method halsband_loesen {
		undefine $.halsband;
	}
	...
}

class Hund is Saeugetier does Haustier {
	...
}
[[[endsyntax]]]</pre>
	<p>Wie das Beispiel zeigt, inkorporiert eine Klasse eine Rolle mit dem
	Schlüsselwort <code>does</code>.</p>

	
