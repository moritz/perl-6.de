[[[menu main tut p5 index]]]
[[[setvar title Tutorial für Perl 5-Programmierer]]]
<div id="content">
	<h1>Perl 6 für Perl 5-Programmierer</h1>

	<p>Trotz vieler Änderungen von p5 zu p6 ist auch vieles gleich
	geblieben, was es alt eingesessenen Perl 5-Programmieren sicher
	leichter macht Perl 6 zu lernen als anderen.</p>

	<p>Das hier ist ein Versuch, die wichtigsten Änderungen
	zusammenzufassen, die häufigsten am Anfang, danach grob nach
	Kategorien.</p>

	<h2>Verschiedenes</h2>

	<p><code>use strict;</code> ist per default angeschaltet, Ausnahme
	sind Einzeiler die mit <code>perl -e '$code'</code> ausgeführt
	werden.</p>

	<p>Für viele Funktionen gibt es jetzt die <code>.</code>-Notation:</p>

<pre>[[[syntax perl6]]]
my @list;
@list.push "foo"	# wie push @list, "foo"
"foo".print		# wie print "foo";
[[[endsyntax]]]</pre>
	<p>Die alte Notation ist immer noch unterstützt.</p>

	<p>Die <code>print</code>-Funktion hat eine eine Schwester, die ein
	Newline am Ende anhängt:<code>say</code></p>
<pre>[[[syntax perl6]]]
my $answer  = 7 * 6;
# alle folgenden Varianten sind äquivalent:
print $answer, "\n";
say $answer;
$answer.say;
[[[endsyntax]]]</pre>

	<h2>Sigils, Arrays und Hashes</h2>

	<p>Wie bisher fangen Skalare mit <code>$</code>, Arrays mit
	<code>@</code> und Hashes mit <code>%</code> an.</p>
	
	<p>Allerdings bleibt bei Arrays und Hashes der Sigil beim Zugriff auf
	Elemente erhalten:</p>
<pre> [[[syntax perl6]]]
my @list = 1, 3, 5, 1, 2;
my %hash = (
	'foo' => 'bar',
	'baz' => 'qox',
	);
@list[0]	#früher: $list[0]
%hash{'foo'}	#früher $hash{foo}
[[[endsyntax]]]</pre>

	<p>Das Autoquoting beim Zugriff auf Hashes funktioniert in
	geschweiften Klammern nicht mehr, statt dessen gibt es jetzt
	<code>&lt;...&gt;</code>:</p>

<pre>[[[syntax perl6]]]
my $str = "foo";
%hash{$str} 	# wie bisher
%hash<foo>	# anstatt %hash{foo}
%hash{'foo'}	# wie bisher
[[[endsyntax]]]</pre>

	<p>Man kann jetzt auch auf Elemente von Array- und Hashreferenzen ohne
	den Pfeil-Operator zugreifen:</p>
<pre>[[[syntax perl6]]]
my $a = [1, 2, [3, 4, 5], 6];
$a[0]		# früher: $a->[0]
$a[2][0]	# früher $a->[0]->[0] oder $a->[0][0]
my $b = { 'a' => 'b', 'c' => [1, 2, 3]};
$b{'a'} 	# früher $b->{a}
$b<a>		# das gleiche
$b<c>[0]	# früher: $b->{c}[0] oder $b->{c}->[0]
[[[endsyntax]]]</pre>
	<p>Auch beim Zugriff auf Objekte ist der Pfeil dem Punkt gewichen.</p>

	<p>Die Anzahl der Elemente eines Arrays bekommt man nun nicht mehr
	über <code>scalar @list</code>, sondern mit elems:</p>
<pre>[[[syntax perl6]]]
# man beachte, dass hier keine Klammern mehr nötig sind:
my @list = 1, 2, 4, 5	

my $num = @list.elems; 		# früher: scalar @list;
$num = elems @list;		# das gleiche
my $last_index = @list.end; 	# früher: $#list
my $last_elem = @list[@list.end]; # früher: $list[$#list]
$last_eleme = @list[-1];	# das gleiche
[[[endsyntax]]]</pre>
	<p><code>qw()</code> wird durch <code>&lt;...&gt;</code> ersetzt und
	hat auch eine interpolierende Form:</p>
<pre>[[[syntax perl6]]]
my @list = <bla blubb>		# früher: qw(bla blubb)
my $str = "bla blubb"
my @l2 = <<foo $str bar>>	# liefert ['foo', 'bla', 'blubb', 'bar']
[[[endsyntax]]]</pre>

	<h2>Twigils</h2>
	<p>Globale Variablen (und ein paar andere) haben ein sekundäres Sigil,
	Twigil genannt:</p>
<pre>[[[syntax perl6]]]
%*ENV			# früher %ENV
@*ARGS			# früher @ARGV
$*IN, $*OUT, $ERR	# früher STDIN, STDOUT, STDERR

# zur Kompilezeit bekannte Symbole:
$?LINE			# früher __LINE__
$?FILE			# früher __FILE__
$?PACKAGE		# früher __PACKAGE__

# Formale Parameter haben ein ^ als twigl:
# in absteigender Reihenfolge sortieren:
sort {$^b <=> $^a}, @list # bisher sort {$b <=> $a} @list
[[[endsyntax]]]</pre>

	<h2>Kontrollstrukturen</h2>

	<p><code>if</code> und <code>unless</code> benötigen jetzt keine
	Klammern mehr um die Bedingung:</p>

<pre>[[[syntax perl6]]]
if $a < 0 {		# if ($a < 0) {
	say "Negativ";	#	print "Negativ\n";
}			# }
[[[endsyntax]]]</pre>
	<p><code>foreach</code> wird zu <code>for</code>, <code>for</code> zu
	<code>loop</code>:</p>

<pre>[[[syntax perl6]]]
my @nums = 1, 2, 3, 23, 42;

for @nums -> my $i {
	# tolle Berechnung mit $i hier
}

# über Hashes iteriern:
for %hash.kv -> my $key, $val {
	say "$key corresponds to $val";
}

# C-Style for-Schleife:
loop (my $i = 0; $i < 10; $i++){
	# tolle Berechnung mit $i hier
}
[[[endsyntax]]]</pre>
	<p><code>while</code> bleibt unverändert (außer dass es auch keine
	runden Klammern mehr um die Bedingung braucht), <code>eval { ...
		}</code> ist jetzt <code>try { ... }</code>.</p>

	<h2>Funktionen</h2>

	<p>Funktionen werden immer noch mit <code>sub</code>-Keyword
	deklariert, und können jetzt Parameterdeklarationen enthalten wie in
	den meisten anderen Programmiersprachen.</p>

<pre>[[[syntax perl6]]]
sub fakultaet(Int $n){
	return  reduce {$^a * $^b}, 1 .. $n;
	# reduce reduziert listen mit der angegbenen Funktion
}

# immer noch möglich:
sub fakultaet2 {
	return  reduce {$^a * $^b}, 1 .. $_[0];
}

# Argumente können jetzt schreibbar gemacht werden:

sub swap($a is rw, $b is rw){
	$a, $b = $b, $a;
}
[[[endsyntax]]]</pre>

	<h2>Typen und <code>ref</code></h2>

	<p>Perl 6 erlaubt es, Typen für Variablen zu deklarieren, es ist aber
	weiterhin optional. Das funktioniert auch mit selbstdeklarierten
	Typen, also <a href="/tutorials/objektmodell">Klassen</a>.</p>

<pre>[[[syntax perl6]]]
my Int $ganzzahl;
my Num $zahl;
my Complex $complexe_zahl;
my Str $string;
my Array of Str @a;

class Foo {
	# defintionen hier
}

my Foo $foo;
[[[endsyntax]]]</pre>

	<p>Die Funktion <code>ref</code> gibt es nicht mehr, dafür gibt es als
	Ersatz zwei Möglichkeiten:</p>
<pre>[[[syntax perl6]]]
my $str = "foo";
say $str.WHAT;		# Ausgabe "Str"

# Überprüfung, ob etwas einen bestimmten Typ hat:
say "Das ist ein String" if $str ~~ Str
[[[endsyntax]]]</pre>

	<p>Die zweite Version verwendet den sogenannten <em>Smart Match
	Operator</em> <code>~~</code>, das auf für Regular Expressions
	verwendet wird. Diese Form sollte man verwenden, wenn man überprüft,
	ob etwas einen bestimmten Typ hat, da das auch Vererbung
	berücksichtigt, d.h. sowohl <code>4 ~~ Int</code> als auch <code>4 ~~
	Num</a> liefern True zurück.</p>

	<h2>Regexes</h2>

	<p>Perl 5 Regexes können in Perl 6 immer noch verwendet werden, aber
	es gibt auch viele Erweiterungen in den neuen <em>Rules</em>. Darüber
	gibt es eine eigene Seite: <a href="regex">Regexes und Rules</a>.</p>

	<h2>Strings</h2>

	<p>Strings in Perl 6 sind Unicode-Strings, die auf verschiedenen
	Ebenen gleichzeitig existieren können (bytes, code points,
	graphemes und charlingua).</p>

	<p>Deswegen gibt es kein <code>length</code> mehr, weil nicht 
	defniert ist, was damit gemeint ist. Stattdessen kann mit
	<code>bytes</code> die Anzahl der Bytes abfragen, mit
	<code>chars</code> die Anzal der Zeichen , mit
	<code>codes</code> die Anzahl der Codepoints, mit
	<code>glyphs</code> die Anzahl der Glyphen
	und mit
	<code>graphs</code> die Anzahl der Grapheme.</p>

	<p>So haben z.B. die deutschen Umlaute in UTF-8 zwei Bytes, aber je
	nur ein char, glyph, code und graph.</p>

	<p>Dagegen können z.B. Ligaturen, also aus zwei Buchstaben zusammen
	gesetzte Zeichen, nur ein Glyph aber mehrere Zeichen haben.</p>

	<p><code>split</code> akzeptiert nur noch Strings an denen gespaltet
	wird, keine Regexes mehr. Dafür gibt es <code>comb</code>, das alle
	Teile eines Strings zurückliefern, die auf eine regex passen - quasi
	ein invertiertes <code>split</code>.</p>

	<p>Mit <code>index</code> und <code>rindex</code> kann man das erste
	und letzte Vorkommen eines substrings finden:</p>

<pre>[[[syntax perl6]]]
"foo".index("o");	# ist 1
"foo".rindex("o");	# ist 2
[[[endsyntax]]]</pre>


	<h2>I/O</h2>

	<p>Aus der <code>&lt;$fh&gt;</code>-Notation zum Lesen aus Filehandles
	ist <code>=&lt;$fh&gt;</code> geworden, und das Zeilenende wird jetzt
	per default automatisch entfernt ("autochomp").</p>

<pre>[[[syntax perl6]]]
my $fn = "foo.txt";
my $file = $fn.open err die "Can't read '$fn': $!";

for =<$file> -> my $line {
	# hier die Zeile verarbeiten
}
$file.close;
[[[endsyntax]]]</pre>

	<p>Die empfohlene Art, eine Datei zeileweise zu lesen ist jetzt eine
	<code>for</code>-Schleife. Und das bedeutet nicht wie in Perl 5, dass
	erst die gesamte Datei gelesen wird und dann darüber iteriert wird,
	sondern die Werte werden dann aus der Datei gelesen, wenn sie
	gebraucht werden.</p>

	<p>Das ist möglich, weil in Perl 6 Listen per default <em>lazy</em>
	sind, was es auch möglich macht, unendliche Listen zu verwenden:
	<code>(1 .. *)[1]</code>.</p>

	<p>Und so geht das Schreiben in Dateien:</p>

<pre>[[[syntax perl6]]]
my $fn = "foo.txt";
my $file = open($fn, :w) err die "Can't open '$fn' for writing: $!";

$file.say: "Erste Zeile der Datei";
# oder:
say $file: "Zweite Zeile";
print $file: 'Diese Zeile hat kein \n am Ende';
$file.close;
[[[endsyntax]]]</pre>

	<p>Man beachte, dass aus <code>print $fh $text</code> jetzt
	<code>print $fh: $text</code> (mit einem zusätlichen Doppelpunkt)
	geworden ist.</p>

	<h2>File Tests</h2>

	<p>File test, wie z.B. <code>-e $filename</code> werden jetzt mit dem
	Smart Match-Operator durchgeführt, und können sowohl auf Strings (als
	Dateinamen) als auch auf Filehandles angewandt werden:</p>

<pre>[[[syntax perl6]]]
my $fn = "/etc/passwd";

if $fn ~~ :e {
	say "$fn existiert";
} else {
	say "Wohl kein Unix...";
}
[[[endsyntax]]]</pre>
	<p>Der <code>:s</code>-Filetest liefert True zurück, wenn die Datei
	nicht leer ist, und im numerischen Kontext gibt er die Länge der Datei
	in Byte zurück.</p>


	<h2>system und exec</h2>

	<p><code>system</code>, also das Ausführen von anderen Programmen,
	heißt jetzt <code>run</code>:</p>
<pre>[[[syntax perl6]]]
my $status = run("mutt -f /path/to/mbox");
# oder
$status = run("mutt", "-f", "/path/to/mbox");
if $status {
	say "Mutt lief erfolgreich";
} else {
	say "Fehler beim ausführen von mutt, Rückgabewert: $status";
}
[[[endsyntax]]]</pre>

	<p>Der Rückgabewert, hier <code>$status</code>, ist im Boolean
	context <code>True</code>, wenn das Programm <code>0</code>
	zurückgeliefert hat, und nicht <code>False</code> wie normale 
	Integer.</a>


	<p><code>exec</code> heißt jetzt <code>runinstead</code>.</p>
